\coursefooterdate{?.06.2024}\head{\Large Урок 7: Разные варианты дека и интерфейс для бинарных деревьев поиска.}
\label{md2tex7}
\hyperref[md2texREADME]{К главному описанию}


\subhead{Краткий план}
\begin{enumerate}
    \item Дек на двусвязном списке.
    \item Дек на трёх стеках.
    \item Дек на закольцованном буфере.
    \item Бинарные деревья поиска.
\end{enumerate}


\subhead{Мотивация}
Кажется, что последняя оставшаяся линейная структура - это дек, его мы реализуем сегодня. И дальше уже перейдём к деревьям.


\subhead{Дек на двусвязном списке}
Дек - это такая структура данных, которая умеют добавлять, брать и удалять элемент из своих начала и конца.

В прошлый раз мы уже сделали двусвязный список, у которого очевидно хорошая асимптотика, а следовательно если дек сделать на двусвязном списке, тоже получим асимптотику $O(1)$ на запрос. Как и в случае со стеком, приватно наследуемся и меняем названия для методов.


\subhead{Дек на трёх стеках}
Если мы вспомним реализацию очереди на двух стеках, то там была левая и правая половина и элементы перекладывались из одной части в другую. Когда мы хотим сделать дек, то тоже заведём левую и правую половину и будем отвечать на запросы так:
\begin{itemize}
    \item Если нужно добавить с какого-то конца, то добавляем на вершину соответствующей половины.
    \item Если нужно удалить с левого конца и левый стек пуст, то переложим с помощью третьего стека половину правого стек в левый (верхнюю половину откладываем во временный стек, нижнюю перекладываем справа налево, элементы из временного стека возвращаем в правый стек). Аналогично если нужно удалить с правого конца и правый стек пуст.
    \item Если нужно удалить с какого-то конца и его стек не пуст, то удаляем элемент с вершины.
\end{itemize}

Если аккуратно порисовать, то станет понятно, что порядок в деке сохраняется правильным и следовательно такая структура точно работает.

Значит осталось только доказать асимптотику, для этого введём потенциал $\Phi_i = |lsz_i - rsz_i|$, где $lsz_i$ и $rsz_i$ - размеры левого и правого стека соответственно после ответа на $i$ запросов. Проверяем условия потенциалов:
\begin{itemize}
    \item Второе условие: $lsz_i, rsz_i \leq i \qquad \Rightarrow \qquad \Phi_i = |lsz_i - rsz_i| \leq i \leq 2q$;
    \item Добавление: $t_i = 1, \Phi_i - \Phi_{i-1} \leq 1 \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} \leq 2$;
    \item Удаление без перебрасываний: $t_i = 1, \Phi_i - \Phi_{i-1} \leq 1 \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} \leq 2$;
    \item Перебрасыванием (слева направо): $t_i = lsz_{i-1}, \Phi_i - \Phi_{i-1} = |x \in \{0, \pm 1\}| - |lsz_{i-1} - 0| \leq -lsz_{i-1} + 1 \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} \leq 1 \leq 2$;
\end{itemize}

Где в пункте с перебрасыванием мы не считаем константу при $lsz_{i-1}$, так как от неё можно избавить умножением потенциала на такую же константу. То есть доказали, что такой дек тоже работает за $O(1)$ на запрос.



\subhead{Дек на закольцованном буфере}
И, наконец, последний хорошо известный способ реализации дека - на закольцованном буфере. К такой реализации не написан код, но это не отменяет его важности для описания.

Храним внутри дека вектор и два индекса: позицию начала и позицию конца дека. При этом индексы мы считаем закольцованным, то есть после последнего элемента идёт первый, а перед первым - последний. Тогда, если вектор ещё заполнился не полностью, то добавляем элемент в свободную ячейку, соседнюю с нужным концом, и двигаем нужный индекс. Аналогично при удалении просто сдвигаем индекс. Если же мы хотим добавить элемент и при этом весь вектор уже заполнен, то заводим новый вектор в два раза больше и копируем все данные туда (или можно много раз сделать \mintinline{cpp}{push_back} и переместить туда наши данные).

Понятно, что такой способ тоже будет работать за амортизировано $O(1)$ на запрос, так как по сути мы упираемся в асимптотику вектора.

Почему же у нас описано так много способов реализовать дек? Во-первых способы выше упорядочены по сложности написания: от простого к сложному. А во-вторых поговаривают, что на практике третий способ будет быстрее второго, а второй будет быстрее первого - именно поэтому нам интересно придумывать как можно больше способов даже с одинаковой асимптотикой, чтобы на практике смотреть какой оказался быстрее (то есть тут мы уже можем гнаться за константой, той самой, которую мы так нещадно отбросили в асимптотике).


\subhead{Бинарные деревья поиска}
Теперь настала пора переходить у бинарным деревьям поиска. Их придумано много разных видов и остальные много занятий мы посвятим им. А сейчас коротки опишем, что будет общего у всех бинарных деревьев поиска:
\begin{itemize}
    \item Структура хранится в виде дереве, где в каждой вершине хранится ключ для поиска (\mintinline{cpp}{value}) и указатель на левого и правого ребёнка (каких-то может не быть, тогда они \mintinline{cpp}{nullptr}).
    \item Для каждой вершины выполняются $t$ условия: $\forall x \in t.L:\ \ x.value < t.value \land \forall x \in t.R:\ \ t.value < x.value$, где за $t.L$ и $t.R$ обозначены левое и правое поддерево соответственно.
    \item Заметим, что в вершинах можно дополнительно хранить ещё какую-то информацию, у нас это размер поддерева (он пока не пересчитывается, но возможность всё же есть).
\end{itemize}

Тогда для всех таких деревьев поиска операция поиска элемента реализуется очень легко:
\begin{itemize}
    \item Стартуем с корня, а если дошли до \mintinline{cpp}{nullptr}, то останавливаемся.
    \item Если в текущей вершине значение ровно такой, как мы ищем, то нужная вершина нашлась.
    \item Иначе если значение в вершине больше, то спускаемся в левое поддерево и повторяем рекурсивно; а если меньше, то спускаемся в правое поддерево и тоже повторяем рекурсивно.
\end{itemize}

Прекрасная же структура! Единственный её минус, что пока наше дерево может получиться не сбалансированным и до разных вершин придётся идти разные пути. Но ничего, эту проблему люди научились решать разными способами и мы тоже научимся.
