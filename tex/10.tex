\coursefooterdate{?.06.2024}\head{\Large Урок 10: Splay Tree: амортизированный логарифм в бинарном дереве поиска.}
\label{md2tex10}
\hyperref[md2texREADME]{К главному описанию}


\subhead{Краткий план}
\begin{enumerate}
    \item Как работает Splay Tree.
    \item Операции со Splay деревом.
    \item Асимптотика операций со Splay деревом.
\end{enumerate}


\subhead{Мотивация}
Мы уже прошли rbst и декартово дерево, но всё же в них используется рандом, так что иногда они могут давать плохие результаты. Но есть и детерминированные деревья поиска с логарифмической глубиной, сегодня познакомимся с Splay Tree - одной из таких структур.


\subhead{Splay Tree}
Основная логика у структуры такая: пусть мы сделали модификацию в какой-то вершине, тогда давайте поднимем эту вершину в корень. Так мы получаем быстрый доступ к недавно модифицированным вершинам, а если подъём сделать правильно то ещё и логарифмическую сложность, правда только амортизировано (то есть в среднем за все запросы).

Всё строится на операции поворота ребра \mintinline{cpp}{rotate_edge}. Пусть у нас были две вершины $A$ и $B$ соединённые ребром и $A$ - родитель $B$. Тогда если аккуратно выписать всех детей в порядке сортировки, то можно довольно понятным способом сделать $B$ родителем $A$, чтобы порядок сортировки сохранился (нарисуйте картинку сами).

Теперь мы хотим научиться поднимать вершину в корень, тогда возможны три ситуации:
\begin{itemize}
    \item У вершины есть только родитель и нет деда (\mintinline{cpp}{zig}) - тогда просто выполним поворот ребра.
    \item У вершины $A$ есть и родитель $B$ и дед $C$, причём родство в разные стороны (\mintinline{cpp}{zig-zag}) - тогда выполним сначала поворот ребра $A - B$, а потом ребра $A - C$.
    \item У вершины $A$ есть и родитель $B$ и дед $C$, причём родство в одну сторону (\mintinline{cpp}{zig-zig}) - тогда выполним сначала поворот ребра $B - C$, а потом ребра $A - B$.
\end{itemize}

Именно такие повороты и подъёмы позволяют достичь амортизированного логарифма.


\subhead{Операции со Splay деревом}
Выше описали как работает операция \mintinline{cpp}{expose(x)} - поднятие вершины $x$ в корень. Теперь выразим обычные операции, которые мы хотим делать с деревьями поиска через уже известные нам:
\begin{itemize}
    \item \mintinline{cpp}{find x}: спускаемся как по бинарному дереву поиска, в конце делаем операцию \mintinline{cpp}{expose} от вершины, куда пришли.
    \item \mintinline{cpp}{merge L, R}: находим самый большой элемент в $L$ (спускаемся в право если можем, иначе останавливаемся) и делаем его \mintinline{cpp}{expose}. После этого подвешиваем $R$ в качестве правого сына к $L$.
    \item \mintinline{cpp}{split x}: делаем поиск элемента $x$ и его подъём с помощью \mintinline{cpp}{expose}. В качестве меньших элементов возвращаем левого сына, а в качестве больших - правого.
    \item \mintinline{cpp}{insert x}: сначала делаем \mintinline{cpp}{split x}, а потом результаты подвешиваем как детей к $x$.
    \item \mintinline{cpp}{erase x}: сначала делаем \mintinline{cpp}{split x}, а потом делаем \mintinline{cpp}{merge} его результатов.
\end{itemize}


\subhead{Асимптотика операций со Splay деревом}
Для каждой вершины $x$ заведём её ранг: $r(x) = \log_2 sz(x)$, где $sz(x)$ - количество вершин в поддереве с корнем в $x$.

Пусть теперь $t$ - корень дерева и мы делаем \mintinline{cpp}{expose x}, тогда хотим доказать, что он будет выполняться не дольше, чем $3r(t) - 3r(x) + 1$.

Здесь нужно аккуратно разобрать все виды подъёмов и показать, что неравенство верно во всех случаях. Если это будет сделано, то когда-то потом :)
