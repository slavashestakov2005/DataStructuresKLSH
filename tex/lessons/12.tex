\coursefooterdate{17.06.2024 -- 06.07.2024}
\head{\Large Урок 12: Пары и set, map, multi- с итераторами.}
\label{md2tex12}
\hyperref[md2texREADME]{\color{cyan}{К главному описанию}}


\subhead{Краткий план}
\begin{enumerate}
    \item Реализация set и map.
    \item Реализация multiset и multimap.
    \item Пары.
    \item Итераторы.
\end{enumerate}


\subhead{Мотивация}
Кто знаком со встроенными в C++ структурами данных знает, что всего пройденного нами разнообразия структур данных там нет. А есть только \mintinline{cpp}{set, map, multiset} и \mintinline{cpp}{multimap}. Так давайте сегодня научимся делать эти структуры на основе изученных нами деревьев.

Во всех этих структурах нам нужен доступ данным за логарифм (такое у нас есть в изученных структурах) и хранение данных в отсортированном порядке (такое тоже есть). Ещё у всех структур есть итераторы, с ними видимо разберёмся отдельно.


\subhead{Реализация set и map}
В зависимости от реализации все изученные нами структуры хранили обычный \mintinline{cpp}{set}. Но давайте всё же выделим пункты, которые нам наверняка гарантируют, что у нас получится именно \mintinline{cpp}{set} (то есть элементы не повторяются):
\begin{itemize}
    \item При добавлении элемента не добавляем новый, если уже есть (или сначала удаляем старую версию, а потом добавляем новую).
    \item При удалении элемента просто удаляем эту единственную версию.
\end{itemize}

Теперь перейдём к \mintinline{cpp}{map}. По сути \mintinline{cpp}{map<A, B>} мы можем заменить на \mintinline{cpp}{set<pair<A, B>>}, где сравнение в паре происходит только по первой координате. Это очень удобная замена, потому что позволяет сводить одну структур к другой. Если же хочется скопировать реализацию чего-то уже сделанного, то можно добавить в каждую вершину с данными (типа \mintinline{cpp}{A}) поле \mintinline{cpp}{info} типа \mintinline{cpp}{B}.


\subhead{Реализация multiset и multimap}
В этих структурах мы хотим иметь возможность хранить несколько элементов с одинаковым ключом. В целом, изученным нами структуры позволяют хранить в них одинаковые элементы (если несколько аккуратнее отнестись к коду), но мне не нравится такой путь, придётся какие-то равенства отдельно рассматривать, ужас. Поэтому предлагается сделать замены виды:
\begin{itemize}
    \item \mintinline{cpp}{multiset<A>} на \mintinline{cpp}{set<pair<A, size_t>>} или на \mintinline{cpp}{set<pair<A, vector<A>>>} -- где в первом случае мы для элемента храним количество его добавлений в структуру, а во втором -- все добавления. Мотивация у второго способа в том, что равные элементы для множества могут иметь разную информацию (например, если оператор сравнения не смотрит на какие-то поля).
    \item \mintinline{cpp}{multimap<A, B>} на \mintinline{cpp}{map<A, vector<B>>} -- для каждого ключа храним список из всех его значений.
\end{itemize}

В целом можно поступать довольно творчески: например если \mintinline{cpp}{B} дорого копировать, то вместо \mintinline{cpp}{vector} использовать \mintinline{cpp}{list}; если мы знаем, что \mintinline{cpp}{A} в \mintinline{cpp}{multiset} какой-то тривиальный встроенный тип со сравнение по умолчанию (например числа или строки), то можно использовать \mintinline{cpp}{pair<A, size_t>}, а не всякие \mintinline{cpp}{pair<A, vector<A>>}.

И замечу, что типы используемые выше: \mintinline{cpp}{vector} и \mintinline{cpp}{list} мы уже научились писать, следовательно можно пользоваться нашими версиями, а не версиями из стандартной библиотеки. Единственное, что у нас раньше не было \mintinline{cpp}{pair}, стоит его реализовать.


\subhead{Пары}
Кажется, что с парами всё достаточно просто: нужно создать шаблонный класс от двух аргументов (разные поля пары могут потенциально иметь разные типы данных). Так что объявление и определение достаточно понятные:

\begin{minted}{cpp}
template<typename F, typename S>
class Pair {
public:
    F first;
    S second;
    Pair();
    Pair(F first, S second);
};
\end{minted}

Кроме того заметим, что в таком случае валидны все три способа создания пар:
\begin{minted}{cpp}
Pair<int, string> pis1;
Pair<int, string> pis2(1, "one");
Pair<int, string> pis3{2, "two"};
\end{minted}


\subhead{Итераторы}
По хорошему множества, словари и их мультиварианты (да и просто бинарное дерево поиска) должны поддерживать итераторы. В целом довольно понятно, как делать \mintinline{cpp}{++} и \mintinline{cpp}{--} итератора: нужно как-то найти следующий элемент в структуре, который больше или меньше данного.

Пусть мы стоим в какой-то вершине $v$ бинарного дерева поиска и хотим найти минимальный элемент, больше текущего. Тогда если есть правый сын, то нужно спустить в него и найти его самого левого ребёнка (минимальный элемент). Если же ребёнка справа нет, то нужно поднять к родителю $p$: если $v$ -- левый сын $p$, то как раз $p$ будет больше $v$; а если $v$ правый сын $p$, то значит всё поддерево $p$ мы обошли, следовательно придётся подниматься ещё выше. Аналогично можно найти максимальный элемент, который больше текущего. Чтобы найти минимальный (или максимальный) элемент в структуре достаточно всё время спускаться пока можем влево (вправо).

В общем понятно, как это написать, но кодовая реализация появится только после появления множеств, словарей и их мультиверсий.
