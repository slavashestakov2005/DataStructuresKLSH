\coursefooterdate{17.06.2024 -- 06.07.2024}
\head{\Large Урок 11: 2-3 дерево: строгий логарифм в дереве поиска.}
\label{md2tex11}
\hyperref[md2texREADME]{\color{cyan}{К главному описанию}}


\subhead{Краткий план}
\begin{enumerate}
    \item Структура B-дерева.
    \item Операции с B-деревом.
    \item Как работает 2-3 дерево.
\end{enumerate}


\subhead{Мотивация}
Кажется, что по прошлым урокам можно предсказать, какую структуры данных мы хотим написать сегодня. В самом деле сначала у нас был логарифм рандомизированный, потом амортизированный, значит сейчас хотим добиться строго логарифма. То есть сегодняшняя структура будет отвечать на любой запрос всегда за логарифм от количества хранимых элементов. С теоретической точки зрения уже нет смысла придумывать структуры лучшее, так как быстрее логарифма отвечать на запросы не получится (иначе бы мы научились сортировать быстрее чем за $O(n \log n)$), и ничего лучше логарифма на каждый запрос тоже не придумано.


\subhead{Структура B-дерева}
Раньше мы познакомились с бинарным деревом поиска: там в каждой вершине хранится какой-то элемент, в детях левее значения меньше, а в детях правее -- больше. Но пусть мы хотим, чтобы из вершины было не два ребёнка, а больше, например $C$. Тогда давайте поделем вершины дерева на два типа: листовые и внутренние. Во внутренних вершинах нужно как-то научиться переходить к какому-то ребёнка, поэтому давайте если у вершины $C$ детей, то в вершине будем хранить $C - 1$ разделяющее число (например максимум во всех детях кроме самого правого). Тогда во внутренних вершинах сможем переходить к правильным вершинам детям и дальше всё аналогично бинарным деревьям поиска.

Заметим, что все данные мы храним только в листьях, а время на запрос к любым данным хотим получить одинаковое. Следовательно нужно как-то сделать так, чтобы все листья были на одной глубине. И в общем понятно, что если рассмотреть рассмотреть полное бинарное дерево и добавить в него один элемент, то понадобится произвести довольно много перестраиваний; аналогично, если добавить что-то между уже существующими числами, то тоже не ясно, как всё хорошо перестроить. Поэтому давайте наложим меньше ограничений на структуру дерева, а именно сделаем у вершины не фиксированное количество детей, а диапазон $[B; 2B)$ (по факту в бинарном дереве у нас тоже $0, 1, 2$ детей, так что идея нам знакома), исключением будет корень, там $[0; 2B)$ вершин.


\subhead{Операции с B-деревом}
Искать данные в B-дереве мы вроде бы научились, поэтому надо научиться их добавлять и удалять.
\begin{itemize}
    \item \mintinline{cpp}{insert x}: пусть хотим вставить какой-то элемент в структуру, тогда поиском можно найти место вставки и добавить элемент туда. Но может так произойти, что после этого у вершины станет $2B$ детей -- в таком случае делим её пополам. После этого проблемы с излишком дочерних вершин поднялись на один слой выше, в общем дальше повторяем такие операции. Если на самом верхнем слое кроме корня добавили ещё что-то, то создаём для них общего родителя и назначаем его корнем.
    \item \mintinline{cpp}{erase x}: пусть хотим удалить какой-то элемент из структуры, тогда поиском можно найти место удаления и убрать его оттуда. После этого у вершины может стать слишком мало детей ($B - 1$), тогда можно или попросить одного ребёнка у брата, или если ни у кого нет лишних детей, то можно отдать брату всех своих. Во втором случае мы удаляем текущую вершину, поэтому проблемный слой переместился на один вверх и дальше продолжаем аналогично.
\end{itemize}

Казалось бы, какая ужасная структура. Но нет, она применяется в жизни, говорят в алгоритмах во внешней памяти (в таких алгоритмах мы можем считывать данные блоками и хотим минимизировать количество обращений ко внешней памяти). Заметим, что теперь глубина дерева стала $\log_B n$, а это даже несколько меньше, чем $\log_2 n$. Но на самом деле мы платим тем, что при спуску по дереву выбор ребёнка будет происходить дольше, за $O(\log_2 B)$. Но опять же в алгоритмах во внешней памяти это всё приемлемо.


\subhead{2-3 дерево}
У нас память не внешняя, поэтому $B$ можем выбрать сами какое хотим, и поэтому выберем $B=2$, получим структуру, называемую 2-3 деревом. Её основные параметры:
\begin{itemize}
    \item У каждой вершины кроме корня $2$ или $3$ ребёнка, во внутренних вершинах кроме корня храним $1$ или $2$ разделяющих элемента.
    \item Для \mintinline{cpp}{find x} просто спускаемся по дереву.
    \item Для \mintinline{cpp}{insert x} спускаемся по дереву, добавляем $x$ куда нужно и если это четвёртый ребёнок, то делим вершину на две и поднимаем проблемы на один слой вверх.
    \item Для \mintinline{cpp}{erase x} спускаемся по дереву, удаляем $x$ откуда нужно и если ребёнок остался всего один, то пытаемся его отдать кому-нибудь, или взять у других ребёнка взаймы. Если пришлось отдать то убираем вершины и поднимаем потенциальную проблему на слой выше.
\end{itemize}

