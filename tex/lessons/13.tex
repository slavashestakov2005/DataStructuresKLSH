\coursefooterdate{?.06.2024}
\head{\Large Урок 13: Хеширование.}
\label{md2tex13}
\hyperref[md2texREADME]{К главному описанию}


\subhead{Краткий план}
\begin{enumerate}
    \item Что такое хеш.
    \item Коллизии.
    \item Хеш-таблица на списках.
    \item Хеш-таблица с открытой адресацией.
\end{enumerate}


\subhead{Мотивация}
Как мы уже поняли, что структуры данных бывают простыми (массив, вектор, очереди и т.д.) и сложными (деревья поиска). Преимущество у первых в том, что операции работают за быстро $O(1)$, а в сложных можно хранить данные упорядочено и обращаться к ним за $O(\log n)$. Причём в древовидных структурах мы можем пользоваться любыми типами данных, а вот в линейных индексация обязательно подряд идущими числами. А кроме того иногда хочется просто хранить множество и не обязательно делать его отсортированным.

В общем из этого следует, что хочется иметь какую-то структуру данных, которая бы могла хранить данные в массиве так, чтобы можно было обращаться по индексу не являющемуся числом. С помощью неё мы например сможем хранить не сортированные множества. И ожидаемое время на любой запрос хотим $O(1)$.


\subhead{Что такое хеш}
Человечество придумало способ, как делать то, что мы захотели выше. Для этого нам понадобится «хеш-функция» $h: S \to Z_m$ - функция, переводящая объекты нашего множества $S$ в целые числа из $[0; m)$. 

Для разных $S$ можно придумать разные хеш-функции. Например, если $S$ - множество чисел, то для $s \in S$ можно например считать хеш так: $h(s) = s\ \%\ m$. Понятно, что это не самый лучший способ, ведь например если мы выберем чётное $m$ и $s$ почему-то тоже будет всегда получаться чётным, то и $h(s)$ будет чётным, что не очень хорошо (по сути мы не пользуемся половиной допустимых значений). Поэтому для чисел можно выбирать например функцию $h(s) = (a \cdot s + b)\ \%\ m$, где $a, b, m$ - простые числа. Не хочется вдаваться в математические выкладки, почему такой хеш это хорошо, желающие могут почитать сами, или потерпеть до института :)

Пусть теперь $S$ - множество строк произвольной длины. Кажется, что в таком случае хеш как-то совсем сложно придумать, но ничего, люди и с этим справились. Рассмотрим полиномиальный хеш, он определяется формулой:

$$h(s) = (s_0 \cdot a^0 + s_1 \cdot a^1 + s_2 \cdot a_2 + \ldots + s_k \cdot a^k)\ \% \ m$$

Здесь $a, m$ - простые числа, $s_i$ - код $i$-го символа в строке $s$, причём нужно чтобы выполнялось $s_i \ne 0$. Чувствуется, что этот хеш достаточно хороший, ведь если взять $a$ больше чем размер алфавита и не брать в конце по модулю $m$, то по полученному хешу можно будет однозначно восстанавливать исходную строку. Нам же приходится брать по модулю, так как бесконечных массивов и бесконечных чисел у нас нет, но такой хеш всё ещё остаётся достаточно хорошим.


\subhead{Коллизии}
Как бы хороша не была наша хеш-функции, всё равно будут случаться «коллизии». Для фанатов формальностей можно написать, что коллизия произошла, когда $\exists s_1, s_2 \in S: s_1 \ne s_2 \land h(s_1) = h(s_2)$, а если человеческим языком, то коллизия - это совпадение хешей для двух различных объектов. Если бы все строки были нам даны заранее, то можно было бы избежать коллизий, построив так называемый идеальный хеш. Но кажется, что этот алгоритм больше интересен с теоретической точки зрения, нежели с практической (так как в реальности мы сейчас поймём, что коллизии не так страшны).

Устроена наша хеш-таблица будет следующем образом: внутри неё хранится Vector, который нам иногда придётся расширять, а его ячейки отвечают за заданный хеш. Для операций добавления / поиска / удаления элемента мы будем считать его хеш и смотреть в нужную ячейку. Дальше может произойти коллизия, поэтому смотреть в одну ячейку будет не так просто, но с этим разберёмся дальше. А вот когда количество элементов в хеш-таблице становится сильно большим (например если уже хранится $n$ объектов, а Vector всего размера $2n$), то будем перестраивать хеш-таблицу: расширим Vector и заново пересчитаем все хеши.

В общем, концептуально довольно не сложно, осталось научиться бороться с коллизиями.


\subhead{Хеш-таблица на списках}
Первая идея, которая приходит в голову - хранить в ячейке Vector сразу много элементов. Общепринято для этих целей использовать List, но в целом вполне можно и любую другую структуру данных (массивы, деревья, хеш-таблицы и т.д.). И тогда для всех операций с заданным хешем нужно будет пройти по соответствующему списку и выполнить явную операцию сравнения.

В целом метод довольно хорош, кроме каких-то уникальных случаев: например, вы храните строки и хеш такой, что он зависит только от последних символов, тогда если все первые символы совпадают, то операции сравнения будут довольно долгими. Но всё же это теоретическая ситуация, и для простых чисел и случайного набора данных такого не произойдёт.


\subhead{Хеш-таблица с открытой адресацией}
Пусть мы всё же не хотим хранить сложные структуры в ячейках (так как для компьютера это лишние прыжки по памяти, что может быть медленным). Тогда в каждой ячейке будем хранить всего по одному элементу, а если произошло коллизия, то будем пытаться работать с соседними элементами. То есть хеш нам даёт стартовую позицию для сохранения данных, а если там сохранено что-то другое, то будем двигаться вправо пока не найдём свободную ячейку.

В целом могло бы показаться, что ходить вправо мы будем довольно долго. Но опять же, если коллизий не очень много, то можно показать, что такой алгоритм будет всё ещё работать быстро. Единственная проблема может быть в его реализации, ведь могут цепочки элементов с одинаковым хешем могут случайно разрываться, поэтому стоит для каждой ячейки хранить самую правую позицию, куда был записан элемент с таким хешем. Но это уже детали реализации, такие проблемы можно решать и по другому (например увеличивать размер таблицы, если много пришлось уйти от стартовой позиции сильно далеко).
