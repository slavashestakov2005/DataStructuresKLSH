\coursefooterdate{17.06.2024 -- 06.07.2024}
\head{\Large Урок 5: Методы монеток и потенциалов.}
\label{md2tex5}
\hyperref[md2texREADME]{\color{cyan}{К главному описанию}}


\subhead{Краткий план}
\begin{enumerate}
    \item Сложность алгоритмов.
    \item Метод монеток.
    \item Применение монеток: Stack и Queue через элементарные операции с Vector.
    \item Метод потенциалов.
    \item Применение потенциалов: операции с Vector.
\end{enumerate}


\subhead{Мотивация}
В прошлые разы мы что-то написали, но почему именно это? Почему Vector нужно расширять в 2 раза, а сжимать в 2 раза только когда можем даже в 4? Сегодня мы разберёмся с этими вопросами и обоснуем, что написанные нами структуры достаточно хороши.


\subhead{Сложность алгоритмов}
Программисты люди ленивые и поэтому хотят оценивать только порядок времени работы. Например $t, 2t, 0.5t$ и $100t$ для них одинаковы (потому что можно найти компьютер чуть помощнее или подождать подольше), а вот $3t^2$ это ужу существенно больше, так как при росте $t$ придётся брать очень много новых компьютеров.

\textbf{\textit{Формальное определение.}} Мы говорим, что функция $t(n)$ имеет сложность $O(f(n))$, если:
$$\exists C > 0\ \ \exists N: \qquad \forall n \geq N \ \ \ \ t(n) \leq C \cdot f(n)$$


\subhead{Метод монеток}
Пусть мы хотим оценить время работы какой-то структуры данных. Тогда будем давать каждому элементу этой структуры какое-то фиксированное число монеток и в моменты работы с этим элементом будем эти монетки забирать. Тогда в сумме мы сделаем количество операций не большее, чем количество выданных монеток, а следовательно на один элемент потратим количество операций равное количеству монеток. Так мы можем доказать, что у какой-то структуры данных линейная сложность.


\subhead{Применение монеток}
Будем считать, что все операции с Vector работают за $O(1)$, то есть посчитаем сложность работы стека и очереди в терминах операций с вектором. Потом, когда мы узнаем, за сколько выполняются операции с Vector, то сможем более детально узнать и сложности стека и очереди, если захотим.

\textbf{Стек.} Здесь всё просто: при добавлении элемента даём ему одну монетку, а при удалении элемента этой монеткой оплачиваем операцию его удаления. Итого на $n$ запросов мы потратим $O(n)$ монеток, значит сложность на все запросы будет $O(n)$, а на один - $O(1)$. Такую же оценку можно получить и из других рассуждений: пусть мы сделали $n$ добавлений и $n$ удалений, тогда каждый элемент один раз добавился и один раз удалился, значит в сумме сделали $O(n)$ операций и $O(1)$ на одну операцию.

\textbf{Очередь.} Здесь уже придётся поступить чуть хитрее: каждому элементу при добавлении даём по три монетки. В момент перекладывания элемента из одного стека в другой мы забираем две монетки (так как это удаление из правого стека и добавление в левый стек - итого две операции), а ещё одну монетку забираем в момент удаления элемента из левого стека. Итого потратили $O(n)$ монет на $n$ запросов, значит один запрос делаем за $O(1)$. И как и в случае со стеком можно было просто посмотреть и заметить, что один элемент два раза добавляется в стеки и два раза удаляется, а отсюда получится та же сложность.


\subhead{Метод потенциалов}
Пусть мы ввели "потенциал" $\Phi_i$ - какая-то величина, характеризующая нашу структуры в момент времени $i$ ($\Phi_0$ - потенциал до всех запросов, $\Phi_i$ - потенциал после обработки $i$ запросов). И пусть произошло $q$ запросов к структуре, каждый запрос занял время $t_1, t_2, \ldots, t_q$. Тогда алгоритм работает амортизировано за $O(f)$, если:
\begin{itemize}
    \item $t_i + \Phi_i - \Phi_{i-1} \leq f$, где $1 \leq i \leq q$;
    \item $0 \leq \Phi_i \leq q \cdot f$, где $0 \leq i \leq q$;
\end{itemize}

\textit{Доказательство.} Сложим все $q$ неравенств первого типа, тогда получим:
$$\left(\sum_{i=1}^q t_i \right) + \Phi_m - \Phi_0 \leq q \cdot f \qquad \Rightarrow \qquad \sum_{i=1}^q t_i \leq 2 q f = O(qf) = q \cdot O(f)$$


\subhead{Применение потенциалов}
Хотим доказать, что операции с Vector работают амортизировано за $O(1)$. Рассмотрим потенциал $\Phi_i = |2sz_i - cap_i|$, где $sz_i$ - величина $size$ в момент времени $i$, а $cap_i$ - величина $capacity$ в момент времени $i$ (обе величины перед запросом $i$). Тогда проверяем оба условия:
\begin{itemize}
    \item Второе условие: $sz_i \leq cap_i \leq 4 \cdot sz_i \qquad \Rightarrow \qquad 2sz_i - sz_i \geq 2sz_i - cap_i \geq 2sz_i - 4 sz_i \qquad \Rightarrow \qquad sz_i \geq 2sz_i - cap_i \geq -2sz_i \qquad \Rightarrow \qquad 0 \leq \Phi_i = |2sz_i - cap_i| \leq 2sz_i \leq 2i \leq 3 q$;
    \item Добавление без релокации: $t_i = 1, \Phi_i - \Phi_{i-1} \leq 2 \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} \leq 3$;
    \item Удаление без релокации: $t_i = 1, \Phi_i - \Phi_{i-1} \leq 2 \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} \leq 3$;
    \item Расширение вектора: $t_i = sz_{i-1}, \Phi_i - \Phi_{i-1} = |2sz_{i-1} - 2sz_{i-1}| - |2sz_{i-1} - sz_{i-1}| = -sz_{i-1} \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} = 0 \leq 3$;
    \item Сжатие вектора: $t_i = sz_i, \Phi_i - \Phi_{i-1} = |2sz_i - 2sz_i| - |2sz_i - 4sz_i| = -2sz_i \qquad \Rightarrow \qquad t_i + \Phi_i - \Phi_{i-1} = -sz_i \leq 3$;
\end{itemize}

Итого показали, что Vector работает амортизировано за $O(3) = O(1)$.

Из этого следует, что во-первых наша реализация хорошая (можно посмотреть какие оценки получатся, если например уменьшать размер при $2size < capacity$), а во-вторых, при оценки сложности стека и очереди мы принимали время работы операций с вектором за $O(1)$, а теперь знаем, что это было честно.
