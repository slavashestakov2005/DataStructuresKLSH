\coursefooterdate{?.06.2024}
\head{\Large Урок 1: Знакомство с ООП.}
\label{md2tex1}
\hyperref[md2texREADME]{К главному описанию}


\subhead{Краткий план}
\begin{enumerate}
    \item Знакомство с ООП (классы, объекты, конструкторы).
    \item Перегрузка операторов.
    \item Пример: класс для дробей.
\end{enumerate}


\subhead{Мотивация}
Идея того, что всё вокруг классы и объекты очень жизненна: например понятно, что многие машины имеют примерно одинаковый функционал и поэтому их можно описать какими-то общими параметрами (класс), но при этом каждая машина имеет что-то своё (цвет, количество бензина в баке, имя хозяина) - поэтому нужны экземпляры классов (объекты).

Если же говорить о программировании, то классом может быть что-то и более абстрактное, например сегодня мы займёмся классом дробей.


\subhead{Модификаторы доступа}
Некоторые данные внутри класса хотелось бы защищать, чтобы никто посторонний к ним не имел доступа - для решения этой проблемы придумали модификаторы доступа:
\begin{itemize}
    \item \mintinline{cpp}{public} - эти данные известны и снаружи класса и внутри;
    \item \mintinline{cpp}{private} - эти данные известны только внутри класса;
    \item \mintinline{cpp}{protected} - эти данные известны внутри класса и в классах наследниках (про наследование поговорим позже);
    \item \mintinline{cpp}{friend} - не является модификатором доступа, но с помощью этого ключевого слова можно разрешать доступ желаемым функциям и классам к \mintinline{cpp}{private} полям;
\end{itemize}

Для дроби хочется чтобы числитель и знаменатель были \mintinline{cpp}{private} так как негоже кому попало их менять.


\subhead{Конструкторы}
Конструкторы вызываются в момент создания объекта класса и нужны чтобы присвоить полям объекта какие-то значения (по умолчанию или переданные в конструктор).


\subhead{Перегрузка операторов}
Не во всех языках программирования существуют перегрузки, но в C++ они реализованы так:
\begin{itemize}
    \item Пусть мы хотим перегрузить оператор \mintinline{cpp}{+}, чтобы имело смысл выражение \mintinline{cpp}{a + b}, где \mintinline{cpp}{a} и \mintinline{cpp}{b} дроби.
    \item Тогда внутри класса определяем:
\end{itemize}
\begin{minted}{cpp}
Frac operator+(Frac other);
\end{minted}
Где \mintinline{cpp}{operator+} - название перегружаемой функции, а \mintinline{cpp}{other} - правый аргумент суммы.
\begin{itemize}
    \item Внутри функция должна работать так, чтобы вычислить значение выражения \mintinline{cpp}{(*this) + other}.
\end{itemize}


\subhead{Перегрузка операторов ввода-вывода}
Как было описано выше, когда мы пишем \mintinline{cpp}{l + r}, то фактически вызывается \mintinline{cpp}{l.operator+(r)}.

Теперь представим, что мы хотим вывести дробь, то есть написать \mintinline{cpp}{cout << f}, тогда должен вызваться \mintinline{cpp}{cout.operator<<(f)}. Но мы ведь не можем залезть внутрь класса для \mintinline{cpp}{cout} чтобы определить там функцию вывода! В таких случаях перегрузку выполняют в виде свободной функции принимающей два аргумента, для нашего примера это будет:
\begin{minted}{cpp}
ostream& operator<<(ostream& os, Frac f);
\end{minted}
Так как \mintinline{cpp}{ostream} это название класса для \mintinline{cpp}{cout}.

Кроме того часто операторы ввода-вывода приходиться делать \mintinline{cpp}{friend}, так как они меняют значения полей класс, как раз такой пример и есть в коде.


\subhead{Константность и ссылки}
В перегрузке оператора вывода мы зачем-то принимали что-то с \mintinline{cpp}{&} и возвращали что-то с таким же непонятным типом. На самом деле символ амперсанда всего лишь означает, что мы не хотим копировать объект при передаче его в функцию.

То есть обычно при вызове функции передаваемые в неё аргументы копируются и их можно редактировать внутри функции независимо от копии вне функции. Но с операторами ввода-вывода копирование было бы чем-то странным, ведь консоль для ввода-вывода всего одна и не хорошо создавать копии, поэтому используется \mintinline{cpp}{&}.

Кроме того иногда объект у вас слишком большой чтобы его копировать и тогда логично использовать \mintinline{cpp}{&}. Если при этом вы не хотите внутри функции как-то объект поменять, то стоит использовать \mintinline{cpp}{const} чтобы показать неизменяемость объекта:
\begin{minted}{cpp}
ostream& operator<<(ostream& os, Frac const& f);
\end{minted}
