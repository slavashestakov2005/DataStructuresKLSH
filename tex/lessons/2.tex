\coursefooterdate{?.06.2024}
\head{\Large Урок 2: Многофайловые программы, простая реализация Vector.}
\label{md2tex2}
\hyperref[md2texREADME]{К главному описанию}


\subhead{Краткий план}
\begin{enumerate}
    \item Необходимость многофайловых программ и как это реализовать на C++.
    \item Пространства имён.
    \item Простая версия класса Vector.
\end{enumerate}


\subhead{Мотивация}
Когда кода становится много, то хочется разбивать его на несколько файлов. Причём разбиение стоит делать не абы как, а согласно какой-то логике, например один файл на один класс (как это делается в Java).

В C++ же разбиение происходит ещё более тонко: на файлы с кодом (\mintinline{cpp}{.cpp}) и заголовочные (\mintinline{cpp}{.h}). В заголовочном файле хранится только описание классов и функций (объявление) тогда как сама реализация делается в файлах с кодом (определение).

Когда вы пишите \mintinline{cpp}{#include <smth>}, то компилятор подставляет вместо этой строки весь код и \mintinline{cpp}{smth}. Но также у компилятора есть правило одного определения (one definition rule), согласно которому объявлений может быть несколько, а определение должно быть только одно. Именно поэтому в заголовочные файлы выносятся объявления и они подключаются с помощью \mintinline{cpp}{#include}. А файлы с кодом никуда не подключаются, поэтому определение получается ровно одно.


\subhead{Пространства имён}
Так случается, что названия чего-то начинают пересекаться (например вы захотели переделать встроенную функцию \mintinline{cpp}{sqrt}, так как иногда она бывает неточна). В таких случаях прибегают к \mintinline{cpp}{namespace} (пространство имён). Их цель в том, чтобы во-первых сгруппировать функции и классы (например пространство имён \mintinline{cpp}{std::} содержит все встроенные функции), а во-вторых для того, чтобы иметь возможность сделать функцию с таким же названием, как уже существующая.


\subhead{Как устроен Vector}
Нам нужно менять размер массива, для этого будем пользоваться указателями и операторами \mintinline{cpp}{new[]} и \mintinline{cpp}{delete[]}. Эти операторы позволяют выделять и удалять память под массив. В текущем варианте Vector будет хранить \mintinline{cpp}{int} и устроен будет так:
\begin{itemize}
    \item Внутри себя хранит \mintinline{cpp}{int* data} - указатель на массив, \mintinline{cpp}{size_t cur_size, cur_capacity} - текущий размер и размер выделенного массива (все поля \mintinline{cpp}{private}).
    \item Если хотим добавить элемент и \mintinline{cpp}{cur_size = cur_capacity}, то выделяем массив в два раза большего размера и всё туда копируем, иначе добавляем в конец выделенного места и сдвигаем \mintinline{cpp}{cur_size}.
    \item Ешё будем поддерживать операции получения последнего элемента и вывод всего контейнера.
\end{itemize}
