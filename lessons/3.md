# Урок 3: Доработка Vector.
[К главному описанию](/README.md)


## Краткий план
1. Аккуратная работа с памятью (копирование).
2. Конструктор от размера.
3. Больше методов: получение размера, удаление из конца; константные методы.
4. Сравнение объектов: оператор `<=>`.
5. Обращение по индексу и итераторы: оператор `[]`, методы `begin` и `end`.


## Мотивация
Казалось бы, мы всё уже написали и оно отлично работает. Но вот нет, мы сегодня рассмотрим такие примеры, по которым будет видно наличие ошибок.

## Копирование
Рассмотрим вот такой код:
```cpp
Vector v1;
v1.push_back(2);
v1.push_back(3);
v1.push_back(5);
v1.push_back(7);
cout << v1;             // 2 3 5 7
Vector v2 = v1;
cout << "v1: " << v1;   // 2 3 5 7
cout << "v2: " << v2;   // 2 3 5 7
v1.push_back(11);
v2.push_back(13);
cout << "v1: " << v1;   // 2 3 5 7 13
cout << "v2: " << v2;   // 2 3 5 7 13
```
Хмм, кажется что-то не так! 

Придумано много разных способов обойти такие ошибки, мы рассмотрим `Swap and Copy`. В нём нужно сделать функции `swap` и `copy` и потом уже аккуратно реализовать остальные функции через них:
```cpp
void copy(Vector const& v);
void swap(Vector& v);
Vector(Vector const& v);                // конструктор копирования, выражается через copy и swap
Vector& operator=(Vector const& v);     // оператор присваивания, выражается через copy и swap
```


## Больше конструкторов
Представим, что мы хотим сделать новый конструктор от количества элементов, в таком случае нам нужен:
```cpp
Vector(size_t size = 0);
```
Где параметр по умолчанию нужно указывать в заголовочном файле, но не нужно указывать в файле с кодом.

Но теперь внимание, "незаметная" разница, у нас будут работать оба варианта:
```cpp
Vector v3(2);       // круглые скобки
Vector v4 = 5;      // присваивание
```

Второй синтаксис какой-то странный, лучше его явно запретить, для этого придумали слово `explicit` (запретить неявные преобразования):
```cpp
explicit Vector(size_t size = 0);
```


## Больше методов
Предположим, что нам понадобились методы, говорящие размер вектора, тогда понятно, что хочется написать:

```cpp
size_t Vector::size() {
    return cur_size;
}
```

Но, представим, что кто-то захотел написать такой код:

```cpp
const Vector v3(v2);
cout << "v3: " << v3;
cout << v3.size() << "\n";
```

В целом все хорошо, понятно чего хотел автор и видно, что константу изменять он не собирался. Но такой код не скомпилируется, ведь метод `size` не помечен как константный. Чтобы это работало нужно написать:
```cpp
size_t Vector::size() const {
    return cur_size;
}
```

Аналогично константными должны быть `get_back` и `capacity`.

Теперь реализуем операцию удаления из конца вектора: удаляем (уменьшаем `cur_size`) и если получилось, что `cur_size * 4 < cur_capacity`, то выделяем заново память размера `cur_size * 2` и копируем туда данные. Почему константы выбраны именно так, мы поговорим на следующем занятии.


## Сравнение объектов
В старых стандартах для определения сравнения между объектами, нужно было перегружать все операторы вручную (на самом деле можно написать только оператор `<` и остальные выразить через него, можете на досуге подумать как именно). В новом же стандарте появился оператор `<=>`, и можно определить его, оператор `==` и остальные операторы получатся сами.

Для этого определяем операторы:

```cpp
std::strong_ordering operator<=>(Vector const& other) const;
bool operator==(Vector const& other) const;
```

Внутри первого можно пользоваться операторами `<=>` для встроенных типов, или возвращать что-то из списка: `less` (левое меньше), `greater` (левое больше), `equal` (равны). Математики придумали не только привычные по жизни порядки `std::strong_ordering`, но и некоторые другие, о них можете почитать сами в свободное время.

Функцию равенства можно определять как-то по умному (именно поэтому стандарт заставляет определять её отдельно), но можно и через `<=>`:
```cpp
bool Vector::operator==(Vector const& other) const {
    return (*this <=> other) == std::strong_ordering::equal;
}
```


## Обращение по индексу и итераторы
Ну все же уже давно хотят получать доступ к элементу вектора по произвольному индексу, давайте научимся!
```cpp
int& operator[](int pos);                   // чтобы смочь присвоить значение по индексу
int const& operator[](int pos) const;       // чтобы получить значение по индексу на чтение
```

Познакомимся со способом сокращения не удобных названий типов:
```cpp
using iterator = int*;                      // теперь вместо int* можно писать iterator
using const_iterator = const int*;          // теперь вместо const int* можно писать const_iterator
```

А теперь мы готовы определить функции `begin` и `end`, чтобы по нашему вектору можно было делать `range-based for`:
```cpp
iterator begin();                           // возвращаем data
iterator end();                             // возвращаем data + cur_size - указатель на
                                            // элемент следующий после конца
const_iterator begin() const;
const_iterator end() const;
```

Теперь оператор вывода можно реализовать без использования `friend`!
