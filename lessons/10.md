[К главному описанию](/README.md)


# Краткий план
1. Как работает Splay Tree.
2. Операции со Splay деревом.
3. Асимптотика операций со Splay деревом.


# Подробное описание
## Мотивация
Мы уже прошли rbst и декартово дерево, но всё же в них используется рандом, так что иногда они могут давать плохие результаты. Но есть и детерминированные деревья поиска с логарифмической глубиной, сегодня познакомимся с Splay Tree - одной из таких структур.


## Splay Tree
Основная логика у структуры такая: пусть мы сделали модификацию в какой-то вершине, тогда давайте поднимем эту вершину в корень. Так мы получаем быстрый доступ к недавно модифицированным вершинам, а если подъём сделать правильно то ещё и логарифмическую сложность, правда только амортизировано (то есть в среднем за все запросы).

Всё строится на операции поворота ребра `rotate_edge`. Пусть у нас были две вершины $A$ и $B$ соединённые ребром и $A$ - родитель $B$. Тогда если аккуратно выписать всех детей в порядке сортировки, то можно довольно понятным способом сделать $B$ родителем $A$, чтобы порядок сортировки сохранился (нарисуйте картинку сами).

Теперь мы хотим научиться поднимать вершину в корень, тогда возможны три ситуации:
- У вершины есть только родитель и нет деда (`zig`) - тогда просто выполним поворот ребра.
- У вершины $A$ есть и родитель $B$ и дед $C$, причём родство в разные стороны (`zig-zag`) - тогда выполним сначала поворот ребра $A - B$, а потом ребра $A - C$.
- У вершины $A$ есть и родитель $B$ и дед $C$, причём родство в одну сторону (`zig-zig`) - тогда выполним сначала поворот ребра $B - C$, а потом ребра $A - B$.

Именно такие повороты и подъёмы позволяют достичь амортизированного логарифма.


## Операции со Splay деревом
Выше описали как работает операция `expose(x)` - поднятие вершины $x$ в корень. Теперь выразим обычные операции, которые мы хотим делать с деревьями поиска через уже известные нам:
- `find x`: спускаемся как по бинарному дереву поиска, в конце делаем операцию `expose` от вершины, куда пришли.
- `merge L, R`: находим самый большой элемент в $L$ (спускаемся в право если можем, иначе останавливаемся) и делаем его `expose`. После этого подвешиваем $R$ в качестве правого сына к $L$.
- `split x`: делаем поиск элемента $x$ и его подъём с помощью `expose`. В качестве меньших элементов возвращаем левого сына, а в качестве больших - правого.
- `insert x`: сначала делаем `split x`, а потом результаты подвешиваем как детей к $x$.
- `erase x`: сначала делаем `split x`, а потом делаем `merge` его результатов.


## Асимптотика операций со Splay деревом
Для каждой вершины $x$ заведём её ранг: $r(x) = \log_2 sz(x)$, где $sz(x)$ - количество вершин в поддереве с корнем в $x$.

Пусть теперь $t$ - корень дерева и мы делаем `expose x`, тогда хотим доказать, что он будет выполняться не дольше, чем $3r(t) - 3r(x) + 1$.

Здесь нужно аккуратно разобрать все виды подъёмов и показать, что неравенство верно во всех случаях. Если это будет сделано, то когда-то потом :)
