[К главному описанию](/README.md)


# Краткий план
1. Знакомство с ООП (классы, объекты, конструкторы).
2. Перегрузка операторов.
3. Пример: класс для дробей.


# Подробное описание
## Мотивация
Идея того, что всё вокруг классы и объекты очень жизненна: например понятно, что многие машины имеют примерно одинаковый функционал и поэтому их можно описать какими-то общими параметрами (класс), но при этом каждая машина имеет что-то своё (цвет, количество бензина в баке, имя хозяина) - поэтому нужны экземпляры классов (объекты).

Если же говорить о программировании, то классом может быть что-то и более абстрактное, например сегодня мы займёмся классом дробей.


## Модификаторы доступа
Некоторые данные внутри класса хотелось бы защищать, чтобы никто посторонний к ним не имел доступа - для решения этой проблемы придумали модификаторы доступа:
- `public` - эти данные известны и снаружи класса и внутри;
- `private` - эти данные известны только внутри класса;
- `protected` - эти данные известны внутри класса и в классах наследниках (про наследование поговорим позже);
- `friend` - не является модификатором доступа, но с помощью этого ключевого слова можно разрешать доступ желаемым функциям и классам к `private` полям;

Для дроби хочется чтобы числитель и знаменатель были `private` так как негоже кому попало их менять.


## Конструкторы
Конструкторы вызываются в момент создания объекта класса и нужны чтобы присвоить полям объекта какие-то значения (по умолчанию или переданные в конструктор).


## Перегрузка операторов
Не во всех языках программирования существуют перегрузки, но в C++ они реализованы так:
- Пусть мы хотим перегрузить оператор `+`, чтобы имело смысл выражение `a + b`, где `a` и `b` дроби.
- Тогда внутри класса определяем:
```cpp
Frac operator+(Frac other);
```
Где `operator+` - название перегружаемой функции, а `other` - правый аргумент суммы.
- Внутри функция должна работать так, чтобы вычислить значение выражения `(*this) + other`.


## Перегрузка операторов ввода-вывода
Как было описано выше, когда мы пишем `l + r`, то фактически вызывается `l.operator+(r)`.

Теперь представим, что мы хотим вывести дробь, то есть написать `cout << f`, тогда должен вызваться `cout.operator<<(f)`. Но мы ведь не можем залезть внутрь класса для `cout` чтобы определить там функцию вывода! В таких случаях перегрузку выполняют в виде свободной функции принимающей два аргумента, для нашего примера это будет:
```cpp
ostream& operator<<(ostream& os, Frac f);
```
Так как `ostream` это название класса для `cout`.

Кроме того часто операторы ввода-вывода приходиться делать `friend`, так как они меняют значения полей класс, как раз такой пример и есть в коде.


## Константность и ссылки
В перегрузке оператора вывода мы зачем-то принимали что-то с `&` и возвращали что-то с таким же непонятным типом. На самом деле символ амперсанда всего лишь означает, что мы не хотим копировать объект при передаче его в функцию.

То есть обычно при вызове функции передаваемые в неё аргументы копируются и их можно редактировать внутри функции независимо от копии вне функции. Но с операторами ввода-вывода копирование было бы чем-то странным, ведь консоль для ввода-вывода всего одна и не хорошо создавать копии, поэтому используется `&`.

Кроме того иногда объект у вас слишком большой чтобы его копировать и тогда логично использовать `&`. Если при этом вы не хотите внутри функции как-то объект поменять, то стоит использовать `const` чтобы показать неизменяемость объекта:
```cpp
ostream& operator<<(ostream& os, Frac const& f);
```
