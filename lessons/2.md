# Урок 2: Многофайловые программы, простая реализация Vector.
[К главному описанию](/README.md)


## Краткий план
1. Необходимость многофайловых программ и как это реализовать на C++.
2. Пространства имён.
3. Простая версия класса Vector.


## Мотивация
Когда кода становится много, то хочется разбивать его на несколько файлов. Причём разбиение стоит делать не абы как, а согласно какой-то логике, например один файл на один класс (как это делается в Java).

В C++ же разбиение происходит ещё более тонко: на файлы с кодом (`.cpp`) и заголовочные (`.h`). В заголовочном файле хранится только описание классов и функций (объявление) тогда как сама реализация делается в файлах с кодом (определение).

Когда вы пишите `#include <smth>`, то компилятор подставляет вместо этой строки весь код и `smth`. Но также у компилятора есть правило одного определения (one definition rule), согласно которому объявлений может быть несколько, а определение должно быть только одно. Именно поэтому в заголовочные файлы выносятся объявления и они подключаются с помощью `#include`. А файлы с кодом никуда не подключаются, поэтому определение получается ровно одно.


## Пространства имён
Так случается, что названия чего-то начинают пересекаться (например вы захотели переделать встроенную функцию `sqrt`, так как иногда она бывает неточна). В таких случаях прибегают к `namespace` (пространство имён). Их цель в том, чтобы во-первых сгруппировать функции и классы (например пространство имён `std::` содержит все встроенные функции), а во-вторых для того, чтобы иметь возможность сделать функцию с таким же названием, как уже существующая.


## Как устроен Vector
Нам нужно менять размер массива, для этого будем пользоваться указателями и операторами `new[]` и `delete[]`. Эти операторы позволяют выделять и удалять память под массив. В текущем варианте Vector будет хранить `int` и устроен будет так:
- Внутри себя хранит `int* data` - указатель на массив, `size_t cur_size, cur_capacity` - текущий размер и размер выделенного массива (все поля `private`).
- Если хотим добавить элемент и `cur_size = cur_capacity`, то выделяем массив в два раза большего размера и всё туда копируем, иначе добавляем в конец выделенного места и сдвигаем `cur_size`.
- Ешё будем поддерживать операции получения последнего элемента и вывод всего контейнера.
