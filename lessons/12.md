# Урок 12: Пары и set, map, multi- с итераторами.
[К главному описанию](/README.md)


## Краткий план
1. Реализация set и map.
2. Реализация multiset и multimap.
3. Пары.
4. Итераторы.


## Мотивация
Кто знаком со встроенными в C++ структурами данных знает, что всего пройденного нами разнообразия структур данных там нет. А есть только `set, map, multiset` и `multimap`. Так давайте сегодня научимся делать эти структуры на основе изученных нами деревьев.

Во всех этих структурах нам нужен доступ данным за логарифм (такое у нас есть в изученных структурах) и хранение данных в отсортированном порядке (такое тоже есть). Ещё у всех структур есть итераторы, с ними видимо разберёмся отдельно.


## Реализация set и map
В зависимости от реализации все изученные нами структуры хранили обычный `set`. Но давайте всё же выделим пункты, которые нам наверняка гарантируют, что у нас получится именно `set` (то есть элементы не повторяются):
- При добавлении элемента не добавляем новый, если уже есть (или сначала удаляем старую версию, а потом добавляем новую).
- При удалении элемента просто удаляем эту единственную версию.

Теперь перейдём к `map`. По сути `map<A, B>` мы можем заменить на `set<pair<A, B>>`, где сравнение в паре происходит только по первой координате. Это очень удобная замена, потому что позволяет сводить одну структур к другой. Если же хочется скопировать реализацию чего-то уже сделанного, то можно добавить в каждую вершину с данными (типа `A`) поле `info` типа `B`.


## Реализация multiset и multimap
В этих структурах мы хотим иметь возможность хранить несколько элементов с одинаковым ключом. В целом, изученным нами структуры позволяют хранить в них одинаковые элементы (если несколько аккуратнее отнестись к коду), но мне не нравится такой путь, придётся какие-то равенства отдельно рассматривать, ужас. Поэтому предлагается сделать замены виды:
- `multiset<A>` на `set<pair<A, size_t>>` или на `set<pair<A, vector<A>>>` -- где в первом случае мы для элемента храним количество его добавлений в структуру, а во втором -- все добавления. Мотивация у второго способа в том, что равные элементы для множества могут иметь разную информацию (например, если оператор сравнения не смотрит на какие-то поля).
- `multimap<A, B>` на `map<A, vector<B>>` -- для каждого ключа храним список из всех его значений.

В целом можно поступать довольно творчески: например если `B` дорого копировать, то вместо `vector` использовать `list`; если мы знаем, что `A` в `multiset` какой-то тривиальный встроенный тип со сравнение по умолчанию (например числа или строки), то можно использовать `pair<A, size_t>`, а не всякие `pair<A, vector<A>>`.

И замечу, что типы используемые выше: `vector` и `list` мы уже научились писать, следовательно можно пользоваться нашими версиями, а не версиями из стандартной библиотеки. Единственное, что у нас раньше не было `pair`, стоит его реализовать.


## Пары
Кажется, что с парами всё достаточно просто: нужно создать шаблонный класс от двух аргументов (разные поля пары могут потенциально иметь разные типы данных). Так что объявление и определение достаточно понятные:

```cpp
template<typename F, typename S>
class Pair {
public:
    F first;
    S second;
    Pair();
    Pair(F first, S second);
};
```

Кроме того заметим, что в таком случае валидны все три способа создания пар:
```cpp
Pair<int, string> pis1;
Pair<int, string> pis2(1, "one");
Pair<int, string> pis3{2, "two"};
```


## Итераторы
По хорошему множества, словари и их мультиварианты (да и просто бинарное дерево поиска) должны поддерживать итераторы. В целом довольно понятно, как делать `++` и `--` итератора: нужно как-то найти следующий элемент в структуре, который больше или меньше данного.

Пусть мы стоим в какой-то вершине $v$ бинарного дерева поиска и хотим найти минимальный элемент, больше текущего. Тогда если есть правый сын, то нужно спустить в него и найти его самого левого ребёнка (минимальный элемент). Если же ребёнка справа нет, то нужно поднять к родителю $p$: если $v$ -- левый сын $p$, то как раз $p$ будет больше $v$; а если $v$ правый сын $p$, то значит всё поддерево $p$ мы обошли, следовательно придётся подниматься ещё выше. Аналогично можно найти максимальный элемент, который больше текущего. Чтобы найти минимальный (или максимальный) элемент в структуре достаточно всё время спускаться пока можем влево (вправо).

В общем понятно, как это написать, но кодовая реализация появится только после появления множеств, словарей и их мультиверсий.
